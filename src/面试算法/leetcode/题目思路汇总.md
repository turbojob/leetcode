# leetcode 题目

## 1、494 target sum

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数

````
方式1：
f(index, rest) 
	当前来到index位置，累加出rest的方法数 返回
加入缓存->dp  可以过
````

```
方式2：
1、所有的数 正负没有关系，全变成正数也可以
2、如果target大于0 且大于所有的累加和，肯定不可以
		    小于0 且小于所有的累加和  肯定不可以
3、假设所有去取+的集合 为P，取-的为N
	P+N = sum
	P-N = target
	所以P=（sum+target）/2
如果相加是个奇数，肯定也不是答案

问题转化成 在数组中，每个数选或者不选，最终搞出累加和为p的方法数

dp[i][j] 表示 从i位置出发  剩下target要求 的方法数
dp: 3ms
可以继续空间压缩 ：2ms 压缩到极致了已经
```

## 2、3 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

````
每一个位置的字符，需要快速知道上一次自己出现的位置
i位置：
    min
    （1）当前位置-上一次出现的位置
    （2）上一个位置的长度+1
注意最开始从1开始，map不要遗漏0号位置
````

## 3、513 找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

来自字节 每日一题

基本思路：层次遍历，每一层都记录着当前层最左边的节点

值得注意的是层次遍历，每次提前获取queue的大小，实现每一层的遍历

## 4、1139  最大的以 1 为边界的正方形

 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/largest-1-bordered-square
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法：枚举所有的正方形    枚举容易 验证复杂 超时
加速：预处理
	需要两个信息：左侧有多少个连续的1，下册有多少个连续的1
	对于正方形，快速check
````



## 5、98 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/validate-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
解法1：二叉树的信息
	最大值、最小值、是不是搜索树
注意此时 可能测试用例有负数，对于null情况，最大值要赋值Long.MIN_VALUE，最小值复制Long.MAX_VALUE
````

````
解法2：中序遍历
	中序遍历保存遍历信息
	在遍历一次  保证升序
````

## 6、674 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法，每一个位置为结尾的lis长度是多少
空间压缩  一个变量足够，即上一个位置的lis长度
````



## 7、525  连续数组

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

````
把所有的0变成-1
前缀和
变成求 区间和为0的问题
	==》hashmap找前缀和相同的 最长距离
````

## 8、546 移除盒子

给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。

返回 你能获得的最大积分和 。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-boxes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
很经典的动态规划的  外部信息简化的例子
f(l, r, k) 表示  在l...r做选择，其中l位置 前面有k 个和arr[l]一样值的数
尝试的角度：前面k个数  和这里的哪个一起消除？
1、和当前[L]位置进行消除
	前面k个加上当前，总共k+1个数，所以
	（k+1）*(k+1) + f(L+1, R, 0)	
						   已经消除完了，所以这里写的0
2、和[L]位置之后的某一个个数 进行消除
	1 1 1 1 1 | 1 1 2 3 1 3 1 1
	            L       i     R
	上面一般的位置i，范围【L+1, R】
	如果想和这个i结合，先把[L+1,i-1]的删除，此时i位置前面相当于有了k+1个一样的数
	f(L+1, i-1， 0) + f(i, R, k+1)
	
	如果是想和多个后面去结合，相当于先结合一个，然后让后面继续走流程。比如下面想让和i之后的多个1去结合，那从i出发即可
	1 1 1 1 1 | 1 2 1 1 1 2 2
                 L   i       R
    
暴力尝试 超时，能过20/63个例子
加上一个三维数组，进行缓存，可以通过， 106ms
````



## 9、1302 层数最深叶子节点的和

给你一棵二叉树的根节点 `root` ，请你返回 **层数最深的叶子节点的和** 。

````
层次遍历 统计每一层的 和即可
````

## 10、467 [环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：

"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...." . 
现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/unique-substrings-in-wraparound-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````java
这里面保证不重复，用的不是hash set，而是 以字母为结尾去度量
必须以a为结尾的最长串长度，必须以b为结尾的最长串长度。。。
	比如必须d结尾的长度是4， abcd  这个情况，所以有4个答案：ad,bd,cd,d
	
在遍历所有位置的时候，看看能不能往左扩。如果左边的和他 满足 相邻关系，连续串的长度+1

两个变量：到目前为止，最长的长度 len；box[i] 表示i+'a' 字母的 最长长度是多少
char a = p.charAt(i-1), b = p.charAt(i);
if((a=='z' && b == 'a') || a+1==b){
   len++;
}else{
   len = 1;
}
box[b - 'a'] = Math.max(box[b - 'a'], len);
````

## 11、699 掉落的方块

在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。

第 i 个掉落的方块（positions[i] = (left, side_length)）是正方形，其中 left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。

每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。

方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，因为只有底边才具有粘性。

 

返回一个堆叠高度列表 ans 。每一个堆叠高度 ans[i] 表示在通过 positions[0], positions[1], ..., positions[i] 表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/falling-squares
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
值得注意的点：
（1）这道题没有原始数组，初始化线段树只需要总长度n即可
（2）水平轴每个数数值很大，需要先自己对元素之序列化。因为线段树忽略0，所以提供的下标应该从1开始。
（3）区间之间有顺序，所以用Treeset排个序。
（4）彼此相连认为不算的，所以右=info[0]+info[1]-1
（5）线段树的change操作，还要在max上进行修改。这里max就相当于我们的原始数组。
（6）往下分发的时候，需要加上等于号。即恰好包含一个点时的情况不能忽略。
````

## 12、658  [ 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。

整数 a 比整数 b 更接近 x 需要满足：

|a - x| < |b - x| 或者
|a - x| == |b - x| 且 a < b

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/find-k-closest-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



````
直接最优解：
（1）二分查找到x位置在哪里，因为可能不在数组里面，所以是按照<=x的最右位置进行查找。
（2）P1指向上个位置，P2指向下一个位置，不断比较他俩和x的差值，谁小谁加入linkedlist。因为本身有序，所以P1的加入头，P2的加入尾，肯定有序。
（3）注意边界，p1 p2 可能越界。类似归并排序的方式。
（4）要求总共k 个，所以 有一个 大小限制。
o(log n + k)  logn 来查找，k对应着双指针

暴力解：
	对数组排序，按照和x的差的绝对值排序。 O(nlogn)
````

## 13、155   [最小栈](https://leetcode.cn/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/min-stack
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
增加一个最小栈，保存每一步的最小值即可。
````

## 14、[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/sliding-window-maximum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
滑动窗口的最大值
【1 3 -1 -1 -3】
  来到1，放着1
  来到3，发现3比1：意味着从出发点到这个位置，不论什么最大值都是3。1就应该丢弃
  来到-1，小于3，放进队列，这样当3弹出是，还有“余地”
  来到-1，相同的数，此时要弹出-1，否则当弹出上一个-1时，第二个-1 没法表示了
  
  规则：队列尾巴对应的值 <= 当前，弹出
````

