# leetcode 题目

## 1、494 target sum

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数

````
方式1：
f(index, rest) 
	当前来到index位置，累加出rest的方法数 返回
加入缓存->dp  可以过
````

```
方式2：
1、所有的数 正负没有关系，全变成正数也可以
2、如果target大于0 且大于所有的累加和，肯定不可以
		    小于0 且小于所有的累加和  肯定不可以
3、假设所有去取+的集合 为P，取-的为N
	P+N = sum
	P-N = target
	所以P=（sum+target）/2
如果相加是个奇数，肯定也不是答案

问题转化成 在数组中，每个数选或者不选，最终搞出累加和为p的方法数

dp[i][j] 表示 从i位置出发  剩下target要求 的方法数
dp: 3ms
可以继续空间压缩 ：2ms 压缩到极致了已经
```

## 2、3 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

````
每一个位置的字符，需要快速知道上一次自己出现的位置
i位置：
    min
    （1）当前位置-上一次出现的位置
    （2）上一个位置的长度+1
注意最开始从1开始，map不要遗漏0号位置
````

## 3、513 找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

来自字节 每日一题

基本思路：层次遍历，每一层都记录着当前层最左边的节点

值得注意的是层次遍历，每次提前获取queue的大小，实现每一层的遍历

## 4、1139  最大的以 1 为边界的正方形

 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/largest-1-bordered-square
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法：枚举所有的正方形    枚举容易 验证复杂 超时
加速：预处理
	需要两个信息：左侧有多少个连续的1，下册有多少个连续的1
	对于正方形，快速check
````



## 5、98 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/validate-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
解法1：二叉树的信息
	最大值、最小值、是不是搜索树
注意此时 可能测试用例有负数，对于null情况，最大值要赋值Long.MIN_VALUE，最小值复制Long.MAX_VALUE
````

````
解法2：中序遍历
	中序遍历保存遍历信息
	在遍历一次  保证升序
````

## 6、674 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法，每一个位置为结尾的lis长度是多少
空间压缩  一个变量足够，即上一个位置的lis长度
````



