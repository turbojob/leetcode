# leetcode 题目

## 1、494 target sum

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数

````
方式1：
f(index, rest) 
	当前来到index位置，累加出rest的方法数 返回
加入缓存->dp  可以过
````

```
方式2：
1、所有的数 正负没有关系，全变成正数也可以
2、如果target大于0 且大于所有的累加和，肯定不可以
		    小于0 且小于所有的累加和  肯定不可以
3、假设所有去取+的集合 为P，取-的为N
	P+N = sum
	P-N = target
	所以P=（sum+target）/2
如果相加是个奇数，肯定也不是答案

问题转化成 在数组中，每个数选或者不选，最终搞出累加和为p的方法数

dp[i][j] 表示 从i位置出发  剩下target要求 的方法数
dp: 3ms
可以继续空间压缩 ：2ms 压缩到极致了已经
```

## 2、3 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

````
每一个位置的字符，需要快速知道上一次自己出现的位置
i位置：
    min
    （1）当前位置-上一次出现的位置
    （2）上一个位置的长度+1
注意最开始从1开始，map不要遗漏0号位置
````

## 3、513 找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

来自字节 每日一题

基本思路：层次遍历，每一层都记录着当前层最左边的节点

值得注意的是层次遍历，每次提前获取queue的大小，实现每一层的遍历

## 4、1139  最大的以 1 为边界的正方形

 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/largest-1-bordered-square
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法：枚举所有的正方形    枚举容易 验证复杂 超时
加速：预处理
	需要两个信息：左侧有多少个连续的1，下册有多少个连续的1
	对于正方形，快速check
````



## 5、98 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/validate-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
解法1：二叉树的信息
	最大值、最小值、是不是搜索树
注意此时 可能测试用例有负数，对于null情况，最大值要赋值Long.MIN_VALUE，最小值复制Long.MAX_VALUE
````

````
解法2：中序遍历
	中序遍历保存遍历信息
	在遍历一次  保证升序
````

## 6、674 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法，每一个位置为结尾的lis长度是多少
空间压缩  一个变量足够，即上一个位置的lis长度
````



## 7、525  连续数组

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

````
把所有的0变成-1
前缀和
变成求 区间和为0的问题
	==》hashmap找前缀和相同的 最长距离
````

## 8、546 移除盒子

给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。

返回 你能获得的最大积分和 。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-boxes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
很经典的动态规划的  外部信息简化的例子
f(l, r, k) 表示  在l...r做选择，其中l位置 前面有k 个和arr[l]一样值的数
尝试的角度：前面k个数  和这里的哪个一起消除？
1、和当前[L]位置进行消除
	前面k个加上当前，总共k+1个数，所以
	（k+1）*(k+1) + f(L+1, R, 0)	
						   已经消除完了，所以这里写的0
2、和[L]位置之后的某一个个数 进行消除
	1 1 1 1 1 | 1 1 2 3 1 3 1 1
	            L       i     R
	上面一般的位置i，范围【L+1, R】
	如果想和这个i结合，先把[L+1,i-1]的删除，此时i位置前面相当于有了k+1个一样的数
	f(L+1, i-1， 0) + f(i, R, k+1)
	
	如果是想和多个后面去结合，相当于先结合一个，然后让后面继续走流程。比如下面想让和i之后的多个1去结合，那从i出发即可
	1 1 1 1 1 | 1 2 1 1 1 2 2
                 L   i       R
    
暴力尝试 超时，能过20/63个例子
加上一个三维数组，进行缓存，可以通过， 106ms
````



