# leetcode 题目

## 1、494 target sum

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数

````
方式1：
f(index, rest) 
	当前来到index位置，累加出rest的方法数 返回
加入缓存->dp  可以过
````

```
方式2：
1、所有的数 正负没有关系，全变成正数也可以
2、如果target大于0 且大于所有的累加和，肯定不可以
		    小于0 且小于所有的累加和  肯定不可以
3、假设所有去取+的集合 为P，取-的为N
	P+N = sum
	P-N = target
	所以P=（sum+target）/2
如果相加是个奇数，肯定也不是答案

问题转化成 在数组中，每个数选或者不选，最终搞出累加和为p的方法数

dp[i][j] 表示 从i位置出发  剩下target要求 的方法数
dp: 3ms
可以继续空间压缩 ：2ms 压缩到极致了已经
```

## 2、3 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

````
每一个位置的字符，需要快速知道上一次自己出现的位置
i位置：
    min
    （1）当前位置-上一次出现的位置
    （2）上一个位置的长度+1
注意最开始从1开始，map不要遗漏0号位置
````

## 3、513 找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

来自字节 每日一题

基本思路：层次遍历，每一层都记录着当前层最左边的节点

值得注意的是层次遍历，每次提前获取queue的大小，实现每一层的遍历

## 4、1139  最大的以 1 为边界的正方形

 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/largest-1-bordered-square
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法：枚举所有的正方形    枚举容易 验证复杂 超时
加速：预处理
	需要两个信息：左侧有多少个连续的1，下册有多少个连续的1
	对于正方形，快速check
````



## 5、98 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/validate-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
解法1：二叉树的信息
	最大值、最小值、是不是搜索树
注意此时 可能测试用例有负数，对于null情况，最大值要赋值Long.MIN_VALUE，最小值复制Long.MAX_VALUE
````

````
解法2：中序遍历
	中序遍历保存遍历信息
	在遍历一次  保证升序
````

## 6、674 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
最直观的想法，每一个位置为结尾的lis长度是多少
空间压缩  一个变量足够，即上一个位置的lis长度
````



## 7、525  连续数组

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

````
把所有的0变成-1
前缀和
变成求 区间和为0的问题
	==》hashmap找前缀和相同的 最长距离
````

## 8、546 移除盒子

给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。

返回 你能获得的最大积分和 。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-boxes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
很经典的动态规划的  外部信息简化的例子
f(l, r, k) 表示  在l...r做选择，其中l位置 前面有k 个和arr[l]一样值的数
尝试的角度：前面k个数  和这里的哪个一起消除？
1、和当前[L]位置进行消除
	前面k个加上当前，总共k+1个数，所以
	（k+1）*(k+1) + f(L+1, R, 0)	
						   已经消除完了，所以这里写的0
2、和[L]位置之后的某一个个数 进行消除
	1 1 1 1 1 | 1 1 2 3 1 3 1 1
	            L       i     R
	上面一般的位置i，范围【L+1, R】
	如果想和这个i结合，先把[L+1,i-1]的删除，此时i位置前面相当于有了k+1个一样的数
	f(L+1, i-1， 0) + f(i, R, k+1)
	
	如果是想和多个后面去结合，相当于先结合一个，然后让后面继续走流程。比如下面想让和i之后的多个1去结合，那从i出发即可
	1 1 1 1 1 | 1 2 1 1 1 2 2
                 L   i       R
    
暴力尝试 超时，能过20/63个例子
加上一个三维数组，进行缓存，可以通过， 106ms
````



## 9、1302 层数最深叶子节点的和

给你一棵二叉树的根节点 `root` ，请你返回 **层数最深的叶子节点的和** 。

````
层次遍历 统计每一层的 和即可
````

## 10、467 [环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：

"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...." . 
现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/unique-substrings-in-wraparound-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````java
这里面保证不重复，用的不是hash set，而是 以字母为结尾去度量
必须以a为结尾的最长串长度，必须以b为结尾的最长串长度。。。
	比如必须d结尾的长度是4， abcd  这个情况，所以有4个答案：ad,bd,cd,d
	
在遍历所有位置的时候，看看能不能往左扩。如果左边的和他 满足 相邻关系，连续串的长度+1

两个变量：到目前为止，最长的长度 len；box[i] 表示i+'a' 字母的 最长长度是多少
char a = p.charAt(i-1), b = p.charAt(i);
if((a=='z' && b == 'a') || a+1==b){
   len++;
}else{
   len = 1;
}
box[b - 'a'] = Math.max(box[b - 'a'], len);
````

## 11、699 掉落的方块

在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。

第 i 个掉落的方块（positions[i] = (left, side_length)）是正方形，其中 left 表示该方块最左边的点位置(positions[i][0])，side_length 表示该方块的边长(positions[i][1])。

每个方块的底部边缘平行于数轴（即 x 轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。

方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，因为只有底边才具有粘性。

 

返回一个堆叠高度列表 ans 。每一个堆叠高度 ans[i] 表示在通过 positions[0], positions[1], ..., positions[i] 表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/falling-squares
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
值得注意的点：
（1）这道题没有原始数组，初始化线段树只需要总长度n即可
（2）水平轴每个数数值很大，需要先自己对元素之序列化。因为线段树忽略0，所以提供的下标应该从1开始。
（3）区间之间有顺序，所以用Treeset排个序。
（4）彼此相连认为不算的，所以右=info[0]+info[1]-1
（5）线段树的change操作，还要在max上进行修改。这里max就相当于我们的原始数组。
（6）往下分发的时候，需要加上等于号。即恰好包含一个点时的情况不能忽略。
````

## 12、658  [ 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。

整数 a 比整数 b 更接近 x 需要满足：

|a - x| < |b - x| 或者
|a - x| == |b - x| 且 a < b

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/find-k-closest-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



````
直接最优解：
（1）二分查找到x位置在哪里，因为可能不在数组里面，所以是按照<=x的最右位置进行查找。
（2）P1指向上个位置，P2指向下一个位置，不断比较他俩和x的差值，谁小谁加入linkedlist。因为本身有序，所以P1的加入头，P2的加入尾，肯定有序。
（3）注意边界，p1 p2 可能越界。类似归并排序的方式。
（4）要求总共k 个，所以 有一个 大小限制。
o(log n + k)  logn 来查找，k对应着双指针

暴力解：
	对数组排序，按照和x的差的绝对值排序。 O(nlogn)
````

## 13、155   [最小栈](https://leetcode.cn/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/min-stack
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
增加一个最小栈，保存每一步的最小值即可。
````

## 14、[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/sliding-window-maximum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
滑动窗口的最大值
【1 3 -1 -1 -3】
  来到1，放着1
  来到
  ，发现3比1：意味着从出发点到这个位置，不论什么最大值都是3。1就应该丢弃
  来到-1，小于3，放进队列，这样当3弹出是，还有“余地”
  来到-1，相同的数，此时要弹出-1，否则当弹出上一个-1时，第二个-1 没法表示了
  
  规则：队列尾巴对应的值 <= 当前，弹出
````

## 15、040剑指 最大子矩阵大小

给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1 的最大矩形，并返回其面积。

注意：此题 matrix 输入格式为一维 01 字符串数组。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/PLYXKQ
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
单调栈  获取每一个元素 左侧、右侧的最小值
注意这里允许相等，因为要的是最大值，跳过他无所谓，代码里如果等于也会弹出

必须以这一行为结尾的 最大子矩阵大小是多少
	高度*（r-l-1）
````

## 16、85 最大子矩阵大小

同上一题，题目输入不一样

## 17、 1711面试  单词的最近距离

有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/find-closest-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

最直观的解法：

````
hashmap 存放着每一个string出现的位置，因为按照顺序访问的，所以list自然有序
找到第一个 第二个单词所有的可能位置，对于其中一个列表，比如第二个p2
对p2  每一个 位置，在p1 找 <=他最右、>=y他最左的位置，比较一下作为这个位置答案
所有位置过一遍，出答案

34ms   60.8MB
````

最优解：双指针

````java
一次遍历，用p1, p2记录着两个单词当前的位置，因为按照顺序进行的，保证p1 p2最近。每一次尝试更新答案
public int findClosest(String[] words, String word1, String word2){
        int p1 = -1, p2 = -1;
        int ans =Integer.MAX_VALUE;
        for(int i = 0; i < words.length;i++){
            String s = words[i];
            if(s.equals(word1)){
                p1 = i;
            }
            if(s.equals(word2)){
                p2 = i;
            }
            if(p1 != -1 && p2 != -1){
                ans = Math.min(ans, Math.abs(p1-p2));
            }
        }
        return ans;
    }
````

## 19、1021 删除最外层的括号

有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。

例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。

 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/remove-outermost-parentheses
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
f(index)
来到index位置。index一定是左括号，碰到匹配的右括号，删除并返回即可
````

## 20、[986 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)

给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。

返回这 两个区间列表的交集 。

形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。

两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/interval-list-intersections
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
题解特别优雅！
双指针，一个指向 两个起点最大的，一个指向两个终点最小的
可以不考虑移动时机，每一个都进行  26ms

想到双指针的移动时机：谁的结尾小  谁就要去移动，因为对面的肯定不会再去满足了
	1 2 3 4
	           5 6 7
	应该让第一个移动
````

## 21、198 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/house-robber
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
好久没做了，尝试入手
当前来到i号位置去做选择。
如果抢：来到i+2位置
如果不抢：来到i+1位置

递归-->dp优化
````

## 22、468 验证ip地址

给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 "IPv4" ；如果是有效的 IPv6 地址，返回 "IPv6" ；如果不是上述类型的 IP 地址，返回 "Neither" 。

有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 <= xi <= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。

一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:

1 <= xi.length <= 4
xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。
在 xi 中允许前导零。
例如 "2001:0db8:85a3:0000:0000:8a2e:0370:7334" 和 "2001:db8:85a3:0:0:8A2E:0370:7334" 是有效的 IPv6 地址，而 "2001:0db8:85a3::8A2E:037j:7334" 和 "02001:0db8:85a3:0000:0000:8a2e:0370:7334" 是无效的 IPv6 地址。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/validate-ip-address
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
1、split  函数，如果想分割“.”,需要加上转义字符“\\.”
2、如果整行最后一个是点  识别不出来的，比如（11.22.），分割结果只有11  22
3、分割前、分割后是空串的case  
````



## 23、2 两数之和

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/add-two-numbers
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

````
类似合并两个有序链表过程

唯一的注意点是 加入了 hair 头指针
以及最后 如果还有1  要新创建节点
````

